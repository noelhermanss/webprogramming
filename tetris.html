<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Midterm Project NoÃ«l Hermans</title>
    <style>
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            margin: 0 auto;
        }

        .gameContainer {
            margin-right: 20px;
            margin-left: 20px;
        }

        .title {
            font-size: 40px;
            font-weight: bold;
            margin: 0 auto;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }

        .buttonContainer {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        button {
            margin: 1px;
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            border: none;
        }

        .controlButton {
            background-color: #228B22;
            color: #FFFFFF;
            width: 35px; 
        }

        #resetButton {
            background-color: #D2042D; 
            color: #FFFFFF; 
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
</head>
<body>
    <div class="container">
        <div class="gameContainer">
            <h1 class="title">Tetris</h1>

            <canvas id="gridCanvas" width="240" height="480"></canvas>

            <div class="buttonContainer">
                <button class="controlButton" id="playButton" onclick="play()"><i class="fas fa-play"></i></button>
                <button class="controlButton" id="pauseButton" onclick="pause()"><i class="fas fa-pause"></i></button>
                <button class="controlButton" onclick="moveLeft()"><i class="fas fa-arrow-left"></i></button>
                <button class="controlButton" onclick="moveRight()"><i class="fas fa-arrow-right"></i></button>
                <button class="controlButton" onclick="rotate()"><i class="fas fa-redo"></i></button>
                <button id="resetButton" onclick="reset()">Reset</button>
            </div>
        </div>
    </div>

    <script>
        canvas = document.getElementById("gridCanvas");
        context = canvas.getContext("2d");

        canvas.addEventListener('click', function(event) {
            if (!isPaused) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                for (let i = 0; i < activeBlocks.length; i++) {
                    let block = activeBlocks[i];

                    // Check if the click is within the boundaries of the block
                    if (
                        (mouseX >= block.x1 * cellSize && mouseX <= (block.x1 + 1) * cellSize &&
                        mouseY >= block.y1 * cellSize && mouseY <= (block.y1 + 1) * cellSize) ||
                        (mouseX >= block.x2 * cellSize && mouseX <= (block.x2 + 1) * cellSize &&
                        mouseY >= block.y2 * cellSize && mouseY <= (block.y2 + 1) * cellSize) ||
                        (mouseX >= block.x3 * cellSize && mouseX <= (block.x3 + 1) * cellSize &&
                        mouseY >= block.y3 * cellSize && mouseY <= (block.y3 + 1) * cellSize) ||
                        (mouseX >= block.x4 * cellSize && mouseX <= (block.x4 + 1) * cellSize &&
                        mouseY >= block.y4 * cellSize && mouseY <= (block.y4 + 1) * cellSize)
                    ) {
                        // Deselect the previously selected block
                        activeBlocks.forEach((otherBlock) => {
                            otherBlock.isSelected = false;
                        });

                        // Select the clicked block
                        block.isSelected = true;

                        // Redraw the canvas to reflect the changes
                        isMoving = true;
                        draw();
                        isMoving = false;
                        break;  // Exit the loop once a block is selected
                    }
                }
            }
        });

        let isDragging = false;
        let dragStartX, dragStartY, dragStartBlock;

        canvas.addEventListener('mousedown', function (event) {
            if (!isPaused) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                activeBlocks.forEach((block) => {
                    // Check if the mouse click is within the boundaries of the selected block
                    if (
                        (mouseX >= block.x1 * cellSize && mouseX <= (block.x1 + 1) * cellSize &&
                            mouseY >= block.y1 * cellSize && mouseY <= (block.y1 + 1) * cellSize) ||
                        (mouseX >= block.x2 * cellSize && mouseX <= (block.x2 + 1) * cellSize &&
                            mouseY >= block.y2 * cellSize && mouseY <= (block.y2 + 1) * cellSize) ||
                        (mouseX >= block.x3 * cellSize && mouseX <= (block.x3 + 1) * cellSize &&
                            mouseY >= block.y3 * cellSize && mouseY <= (block.y3 + 1) * cellSize) ||
                        (mouseX >= block.x4 * cellSize && mouseX <= (block.x4 + 1) * cellSize &&
                            mouseY >= block.y4 * cellSize && mouseY <= (block.y4 + 1) * cellSize)
                    ) {
                        isDragging = true;
                        dragStartX = mouseX - block.x1 * cellSize;
                        dragStartY = mouseY - block.y1 * cellSize;
                        dragStartBlock = block;
                        return;  // Exit the loop once a block is selected
                    }
                });
            }
        });

        canvas.addEventListener('mousemove', function (event) {
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // Calculate the new position of the block based on the mouse movement
                const newX = Math.round((mouseX - dragStartX) / cellSize);
                const newY = Math.round((mouseY - dragStartY) / cellSize);

                // Check if the new position is legal and update the block's coordinates
                if (newX >= 0 && newX <= columns - (dragStartBlock.x4 - dragStartBlock.x1) &&
                    newY >= 0 && newY <= rows - (dragStartBlock.y4 - dragStartBlock.y1) &&
                    !hitBlock(activeBlocks, dragStartBlock, newX, newY)) {

                    const xOffset = dragStartBlock.x1 - newX;
                    const yOffset = dragStartBlock.y1 - newY;

                    dragStartBlock.x1 -= xOffset;
                    dragStartBlock.x2 -= xOffset;
                    dragStartBlock.x3 -= xOffset;
                    dragStartBlock.x4 -= xOffset;

                    dragStartBlock.y1 -= yOffset;
                    dragStartBlock.y2 -= yOffset;
                    dragStartBlock.y3 -= yOffset;
                    dragStartBlock.y4 -= yOffset;
                }

                // Redraw the canvas to reflect the changes
                isMoving = true;
                draw();
                isMoving = false;

                // Check if the block is dead after moving
                if (hitBottom(dragStartBlock)) {
                    dragStartBlock.isDead = true;

                    // if the block is the selected block, select another block
                    if (dragStartBlock.isSelected) {
                        dragStartBlock.isSelected = false;
                        let nextBlock = activeBlocks.find((block) => block.isDead === false);
                        if (nextBlock) {
                            nextBlock.isSelected = true;
                        }
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', function () {
            isDragging = false;
        });

        function hitBlock(blocks, currentBlock, newX, newY) {
            // Check if the new position collides with other blocks
            return blocks.some((block) => {
                if (block !== currentBlock) {
                    return (
                        (newX >= block.x1 && newX <= block.x4 && newY >= block.y1 && newY <= block.y4) ||
                        (newX + (currentBlock.x4 - currentBlock.x1) >= block.x1 &&
                            newX + (currentBlock.x4 - currentBlock.x1) <= block.x4 &&
                            newY + (currentBlock.y4 - currentBlock.y1) >= block.y1 &&
                            newY + (currentBlock.y4 - currentBlock.y1) <= block.y4)
                    );
                }
                return false;
            });
        }

        const rows = 20;
        const columns = 10;
        const cellSize = Math.min(canvas.width / columns, canvas.height / rows);

        const cellColor = '#ebeef2';
        const spaceColor = '#FFFFFF';

        let isStarted = false;
        let isPaused = false;

        let activeBlocks = [];

        let isMoving = false;

        let ceiling = 3;

        const blockColors = [
            '#00FF00',
            '#0000FF',
            '#FFFF00',
            '#00FFFF',
            '#FF00FF',
            '#FFA500'
        ];

        const blockShapes = [
            [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }],
            [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 3, y: 0 }],
            [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 1, y: 1 }],
            [{ x: 0, y: 1 }, { x: 0, y: 2 }, { x: 1, y: 1 }, { x: 1, y: 0 }],
            [{ x: 0, y: 2 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 1, y: 2 }],
        ];

        function drawGrid() {
            // Draw the grid
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < columns; col++) {
                    const x = col * cellSize;
                    const y = row * cellSize;

                    context.fillStyle = cellColor;
                    context.fillRect(x, y, cellSize, cellSize);

                    context.strokeStyle = spaceColor;
                    context.strokeRect(x, y, cellSize, cellSize);
                }
            }
            
            // Draw the ceiling line
            context.beginPath();
            context.moveTo(0, ceiling * cellSize);
            context.lineTo(canvas.width, ceiling * cellSize);
            context.strokeStyle = 'red';
            context.stroke();
        }
        drawGrid();

        class Block {
            constructor(id, colour, x1, x2, x3, x4, y1, y2, y3, y4, isSelected, isDead) {
                this.id = id;
                this.colour = colour;
                this.x1 = x1;
                this.x2 = x2;
                this.x3 = x3;
                this.x4 = x4;
                this.y1 = y1;
                this.y2 = y2;
                this.y3 = y3;
                this.y4 = y4;
                this.isSelected = isSelected;
                this.isDead = isDead;
            }
        }

        function createBlock(){
            const randomColor = blockColors[Math.floor(Math.random() * blockColors.length)];
            const randomShape = blockShapes[Math.floor(Math.random() * blockShapes.length)];

            const block = new Block(
                Date.now(),
                randomColor,
                randomShape[0].x,
                randomShape[1].x,
                randomShape[2].x,
                randomShape[3].x,
                randomShape[0].y,
                randomShape[1].y,
                randomShape[2].y,
                randomShape[3].y,
                false,
                false
            );

            return block;
        }

        function drawBlock(block) {
            context.fillStyle = block.colour;
            context.fillRect(block.x1 * cellSize, block.y1 * cellSize, cellSize, cellSize);
            context.fillRect(block.x2 * cellSize, block.y2 * cellSize, cellSize, cellSize);
            context.fillRect(block.x3 * cellSize, block.y3 * cellSize, cellSize, cellSize);
            context.fillRect(block.x4 * cellSize, block.y4 * cellSize, cellSize, cellSize);

            if (block.isSelected) {
                context.strokeStyle = '#D2042D';
            }
            else {
                context.strokeStyle = '#FFFFFF';
            }
            context.lineWidth = 2;
            context.strokeRect(block.x1 * cellSize, block.y1 * cellSize, cellSize, cellSize);
            context.strokeRect(block.x2 * cellSize, block.y2 * cellSize, cellSize, cellSize);
            context.strokeRect(block.x3 * cellSize, block.y3 * cellSize, cellSize, cellSize);
            context.strokeRect(block.x4 * cellSize, block.y4 * cellSize, cellSize, cellSize);
        }

        function hitBottom(block) {
            // Get all coordinates beneath the block
            const coordinatesBeneath = [
                { x: block.x1, y: block.y1 + 1 },
                { x: block.x2, y: block.y2 + 1 },
                { x: block.x3, y: block.y3 + 1 },
                { x: block.x4, y: block.y4 + 1 }
            ];

            // Check if any of the coordinates beneath the block are occupied by another block
            return coordinatesBeneath.some(
                (coordinate) =>
                    activeBlocks.some(
                        (otherBlock) =>
                            otherBlock.id !== block.id &&
                            (otherBlock.x1 === coordinate.x && otherBlock.y1 === coordinate.y ||
                            otherBlock.x2 === coordinate.x && otherBlock.y2 === coordinate.y ||
                            otherBlock.x3 === coordinate.x && otherBlock.y3 === coordinate.y ||
                            otherBlock.x4 === coordinate.x && otherBlock.y4 === coordinate.y)
                    ) ||
                    coordinate.y >= rows // Check if any of the coordinates beneath the block are at the bottom of the grid
            );
        }

        function removeFullRows() {
            for (let row = rows - 1; row >= 0; row--) {
                let isFullRow = true;

                // Check if all cells in the row are occupied by a block
                for (let col = 0; col < columns; col++) {
                    if (!activeBlocks.some(block =>
                        (block.y1 === row && block.isDead && (block.x1 === col || block.x2 === col || block.x3 === col || block.x4 === col)) ||
                        (block.y2 === row && block.isDead && (block.x1 === col || block.x2 === col || block.x3 === col || block.x4 === col)) ||
                        (block.y3 === row && block.isDead && (block.x1 === col || block.x2 === col || block.x3 === col || block.x4 === col)) ||
                        (block.y4 === row && block.isDead && (block.x1 === col || block.x2 === col || block.x3 === col || block.x4 === col))
                    )) {
                        isFullRow = false;
                        break;
                    }
                }

                if (isFullRow) {
                    // Iterate over the blocks to adjust positions or delete them
                    for (let i = 0; i < activeBlocks.length; i++) {
                        let block = activeBlocks[i];

                        // First, we check if the block has all of its cells in the row
                        // If so, we delete the block

                        if (block.y1 === row && block.y2 === row && block.y3 === row && block.y4 === row) {
                            activeBlocks.splice(i, 1);
                            i--;
                        } else {
                            // If not, we check if the block has any cells above the row
                            // If so, we copy the coordinates of the cells above the row to the cells in the row

                            if (block.y1 === row) {
                                if (block.y2 !== row) {
                                    block.y1 = block.y2;
                                    block.x1 = block.x2;
                                } else if (block.y3 !== row) {
                                    block.y1 = block.y3;
                                    block.x1 = block.x3;
                                } else {
                                    block.y1 = block.y4;
                                    block.x1 = block.x4;
                                }
                            }

                            if (block.y2 === row) {
                                if (block.y1 !== row) {
                                    block.y2 = block.y1;
                                    block.x2 = block.x1;
                                } else if (block.y3 !== row) {
                                    block.y2 = block.y3;
                                    block.x2 = block.x3;
                                } else {
                                    block.y2 = block.y4;
                                    block.x2 = block.x4;
                                }
                            }

                            if (block.y3 === row) {
                                if (block.y1 !== row) {
                                    block.y3 = block.y1;
                                    block.x3 = block.x1;
                                } else if (block.y2 !== row) {
                                    block.y3 = block.y2;
                                    block.x3 = block.x2;
                                } else {
                                    block.y3 = block.y4;
                                    block.x3 = block.x4;
                                }
                            }

                            if (block.y4 === row) {
                                if (block.y1 !== row) {
                                    block.y4 = block.y1;
                                    block.x4 = block.x1;
                                } else if (block.y2 !== row) {
                                    block.y4 = block.y2;
                                    block.x4 = block.x2;
                                } else {
                                    block.y4 = block.y3;
                                    block.x4 = block.x3;
                                }
                            }
                        }
                    }
                }
            }
        }

        let lastBlockTime = Date.now();

        function draw() {
            drawGrid();

            if (!isStarted) {
                // Initialize the game by creating the first block
                let block = createBlock();
                block.isSelected = true;
                activeBlocks.push(block);
                lastBlockTime = Date.now();
                drawBlock(block);
                isStarted = true; // Set isStarted to true after the first block is created
            } else {
                for (let i = 0; i < activeBlocks.length; i++) {
                    let block = activeBlocks[i];

                    // if there is no block selected, select the first block
                    if (!activeBlocks.some(block => block.isSelected)) {
                        block.isSelected = true;
                    }

                    if (block.isDead && block.y1 <= ceiling) {
                        gameOver();
                        return;
                    }

                    if (hitBottom(block)) {
                        // Block can't move down, mark it as dead
                        block.isDead = true;

                        // if the bottom that dies is the selected block, select another block
                        if (block.isSelected) {
                            block.isSelected = false;
                            let nextBlock = activeBlocks.find((block) => block.isDead === false);
                            if (nextBlock) {
                                nextBlock.isSelected = true;
                            }
                        }
                    } else if (!isMoving) {
                        // Block can move down, move it down
                        block.y1++;
                        block.y2++;
                        block.y3++;
                        block.y4++;
                    }

                    drawBlock(block);
                }

                // Check if 5 seconds have passed since the last block creation
                if (Date.now() - lastBlockTime >= 5000) {
                    let newBlock = createBlock();
                    activeBlocks.push(newBlock);
                    lastBlockTime = Date.now(); // Update the last block creation time
                }
            }
            removeFullRows();
        }

        function play() {
            draw(); // Call draw initially
            gameTimeout = setTimeout(play, 1000);
            isPaused = false;
            document.getElementById("playButton").disabled = true;
            document.getElementById("pauseButton").disabled = false;
        }

        function pause() {
            clearTimeout(gameTimeout);
            isPaused = true;
            document.getElementById("playButton").disabled = false;
            document.getElementById("pauseButton").disabled = true;
        }

        function moveLeft() {
            let block = activeBlocks.find((block) => block.isSelected);

            // Check if the block can move left without colliding with boundaries or other blocks
            if (!hitBoundary(block, 'left') && block.isDead === false) {
                block.x1--;
                block.x2--;
                block.x3--;
                block.x4--;
            }

            isMoving = true;
            draw();
            isMoving = false;

            // Check if the block is dead after moving
            if (hitBottom(block)) {
                block.isDead = true;

                // if the block is the selected block, select another block
                if (block.isSelected) {
                    block.isSelected = false;
                    let nextBlock = activeBlocks.find((block) => block.isDead === false);
                    if (nextBlock) {
                        nextBlock.isSelected = true;
                    }
                }
            }
        }

        function moveRight() {
            let block = activeBlocks.find((block) => block.isSelected);

            // Check if the block can move right without colliding with boundaries or other blocks
            if (!hitBoundary(block, 'right') && block.isDead === false) {
                block.x1++;
                block.x2++;
                block.x3++;
                block.x4++;
            }
            
            isMoving = true;
            draw();
            isMoving = false;

            // Check if the block is dead after moving
            if (hitBottom(block)) {
                block.isDead = true;

                // if the block is the selected block, select another block
                if (block.isSelected) {
                    block.isSelected = false;
                    let nextBlock = activeBlocks.find((block) => block.isDead === false);
                    if (nextBlock) {
                        nextBlock.isSelected = true;
                    }
                }
            }
        }

        function hitBoundary(block, direction) {
            // Check if the block is trying to move out of the canvas boundaries
            if (
                (direction === 'left' && (block.x1 - 1 < 0 || block.x2 - 1 < 0 || block.x3 - 1 < 0 || block.x4 - 1 < 0)) ||
                (direction === 'right' && (block.x1 + 1 >= columns || block.x2 + 1 >= columns || block.x3 + 1 >= columns || block.x4 + 1 >= columns))
            ) {
                return true;
            }

            // Check if the block is trying to move into a position where another block is already present
            // Get all coordinates to the left or right of the block
            const leftCoordinates = [
                { x: block.x1 - 1, y: block.y1 },
                { x: block.x2 - 1, y: block.y2 },
                { x: block.x3 - 1, y: block.y3 },
                { x: block.x4 - 1, y: block.y4 }
            ];

            const rightCoordinates = [
                { x: block.x1 + 1, y: block.y1 },
                { x: block.x2 + 1, y: block.y2 },
                { x: block.x3 + 1, y: block.y3 },
                { x: block.x4 + 1, y: block.y4 }
            ];

            // Check if any of the coordinates to the left or right of the block are occupied by another block
            return (
                leftCoordinates.some(
                    (coordinate) =>
                        activeBlocks.some(
                            (otherBlock) =>
                                otherBlock.id !== block.id &&
                                (otherBlock.x1 === coordinate.x && otherBlock.y1 === coordinate.y ||
                                otherBlock.x2 === coordinate.x && otherBlock.y2 === coordinate.y ||
                                otherBlock.x3 === coordinate.x && otherBlock.y3 === coordinate.y ||
                                otherBlock.x4 === coordinate.x && otherBlock.y4 === coordinate.y)
                        )
                ) ||
                rightCoordinates.some(
                    (coordinate) =>
                        activeBlocks.some(
                            (otherBlock) =>
                                otherBlock.id !== block.id &&
                                (otherBlock.x1 === coordinate.x && otherBlock.y1 === coordinate.y ||
                                otherBlock.x2 === coordinate.x && otherBlock.y2 === coordinate.y ||
                                otherBlock.x3 === coordinate.x && otherBlock.y3 === coordinate.y ||
                                otherBlock.x4 === coordinate.x && otherBlock.y4 === coordinate.y)
                        )
                )
            );
        }

        function rotate() {
            // Get the selected block
            let block = activeBlocks.find((block) => block.isSelected);

            // Get the coordinates of the block's center
            const centerX = (block.x1 + block.x2 + block.x3 + block.x4) / 4;
            const centerY = (block.y1 + block.y2 + block.y3 + block.y4) / 4;

            // Get the coordinates of the block's cells relative to the center
            const relativeX1 = block.x1 - centerX;
            const relativeX2 = block.x2 - centerX;
            const relativeX3 = block.x3 - centerX;
            const relativeX4 = block.x4 - centerX;

            const relativeY1 = block.y1 - centerY;
            const relativeY2 = block.y2 - centerY;
            const relativeY3 = block.y3 - centerY;
            const relativeY4 = block.y4 - centerY;

            // Rotate the block's cells
            block.x1 = Math.round(centerX - relativeY1);
            block.x2 = Math.round(centerX - relativeY2);
            block.x3 = Math.round(centerX - relativeY3);
            block.x4 = Math.round(centerX - relativeY4);

            block.y1 = Math.round(centerY + relativeX1);
            block.y2 = Math.round(centerY + relativeX2);
            block.y3 = Math.round(centerY + relativeX3);
            block.y4 = Math.round(centerY + relativeX4);

            // Check if the block can rotate without colliding with boundaries or other blocks
            if (hitBoundary(block, 'left') || hitBoundary(block, 'right') || hitBlock(activeBlocks, block, block.x1, block.y1)) {
                // If not, rotate the block back to its original position
                block.x1 = Math.round(centerX + relativeY1);
                block.x2 = Math.round(centerX + relativeY2);
                block.x3 = Math.round(centerX + relativeY3);
                block.x4 = Math.round(centerX + relativeY4);

                block.y1 = Math.round(centerY - relativeX1);
                block.y2 = Math.round(centerY - relativeX2);
                block.y3 = Math.round(centerY - relativeX3);
                block.y4 = Math.round(centerY - relativeX4);
            }

            isMoving = true;
            draw();
            isMoving = false;

            // Check if the block is dead after rotating
            if (hitBottom(block)) {
                block.isDead = true;

                // if the block is the selected block, select another block
                if (block.isSelected) {
                    block.isSelected = false;
                    let nextBlock = activeBlocks.find((block) => block.isDead === false);
                    if (nextBlock) {
                        nextBlock.isSelected = true;
                    }
                }
            }
        }

        function reset() {
            window.location.reload();
        }

        function gameOver() {
            alert("Game Over!");
            window.location.reload();
        }
    </script>
</body>
</html>